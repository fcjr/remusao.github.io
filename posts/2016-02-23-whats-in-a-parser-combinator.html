<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Simplex Sigillum Veri - What's in a parser combinator?</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Simplex Sigillum Veri</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>What's in a parser combinator?</h1>
            <article>
    <section class="header">
        Posted on February 23, 2016
        
    </section>
    <section>
        <p>As part of my ongoing effort to make progress in Haskell (that’s one of my goals for 2016!), I’m following the <a href="https://courses.edx.org/courses/course-v1:DelftX+FP101x+3T2015/info">MOOC on functionnal programming</a> by <a href="https://twitter.com/headinthebox">Erik Meijer</a> on <em>edX</em>.</p>
<p>The first lessons were pretty basic stuff, and I got through them quickly. Lesson 7 is about <em>Functional parsers</em> and M***** (scary). This is where I encountered my first difficulties, and I thought it would be an interesting writing. I already used parser combinators in Haskell before (mainly <a href="https://hackage.haskell.org/package/parsec">Parsec</a> and <a href="http://hackage.haskell.org/package/attoparsec">Attoparsec</a>), but never really understood how they worked, or at least not enough to implement one myself. So here is my take on the subject. Don’t expect really advanced stuff! It’s just an introduction to the basic concepts, on which we could build more complex and useful tools. In particular, <strong>I won’t talk about</strong>:</p>
<ol style="list-style-type: decimal">
<li>How to report errors.</li>
<li>How to recover from errors.</li>
<li>How to write a parser for a concrete grammar.</li>
</ol>
<p>Instead <strong>I’ll focus on</strong>:</p>
<ol style="list-style-type: decimal">
<li>What a parser <em>is</em>.</li>
<li>How to make parsers <em>compose</em>.</li>
<li>How to use <em>do notation</em> to implement more complex parsers.</li>
</ol>
<p>One of the interesting facts about writing your own parser combinators library, is that you will learn (or consolidate) other knowledges in the process, like: <em>Functors</em>, <em>Applicatives</em> and, of course, <em>Monads</em>, and more generaly, how to <em>design DSL in Haskell</em>. I already knew about this concepts (at least, that’s what I thought…), but knowing what something is from a high level of abstraction, <em>is not the same as knowing how to implement it on a concrete type</em> (like a Parser)!</p>
<h3 id="so-whats-a-parser">So what’s a parser?</h3>
<p>We can view a <em>Parser</em> as <em>something</em> that consumes some input, and outputs a structured representation of what was consumed. For the sake of simplicity, we’ll only consume strings (Haskell type <code>String</code>). So that would be something like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</code></pre></div>
<p>Here <code>a</code> represents the type of what is <em>built</em> from the stream of characters (<code>String</code>). This could be a syntactic tree, or a list of numbers, or anything else. For example a parser that is able to recognize a string like <code>&quot;[1, 2, 3, 4]&quot;</code> could have the type: <code>Parser [Int]</code> (expended to <code>String -&gt; [Int]</code>), which means it takes a <code>String</code> and output a <code>list</code> of integers.</p>
<p>But we’re missing two important properties of a <em>Parser</em>:</p>
<ol style="list-style-type: decimal">
<li>It can <strong>fail to parse</strong> something.</li>
<li>It can <strong>partially consume</strong> its input.</li>
</ol>
<p>To take into account the first point, we could return <code>Maybe a</code> instead of <code>a</code> (resulting in <code>Nothing</code> in case of failure). Note that we could also use a richer type like <code>Either</code> to handle parsing errors. And for the second point, we can return a tuple of a <code>a</code> and a <code>String</code>, which represents the part of the string that wasn’t consumed by the parser. The type would then become:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parser</span> {<span class="ot"> runParser ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>) }</code></pre></div>
<p>As an example of a parser that would fail, if you take our previous <em>parser</em> that is able to handle a list of integers, if you give it the string <code>&quot;[1 ,2&quot;</code>, it will fail, and return <code>Nothing</code>.</p>
<p>Similarely, if we feed the <em>parser</em> with <code>&quot;[1, 2, 3, 4]toto&quot;</code>, it will consume the part of the string that represents the list of integers, and leave <code>&quot;toto&quot;</code> as a remaining input. Thus the result would be: <code>Just ([1, 2, 3, 4], &quot;toto&quot;)</code>.</p>
<p>Let’s implement some very basic parsers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- This parser always fails</span>
<span class="ot">failure ::</span> <span class="dt">Parser</span> a
failure <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="dt">Nothing</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- This parser always succeeds and returns the value given as input (leaving the input string intact)</span>
return<span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
return a <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, s)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- This parser returns the first char of the input string, and fail on empty input</span>
<span class="ot">oneChar ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
oneChar <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span>
            [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
            (c<span class="fu">:</span>xs) <span class="ot">-&gt;</span> <span class="dt">Just</span> (c, xs)</code></pre></div>
<p>Let’s test these parsers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runParser failure <span class="st">&quot;Hello Parser!&quot;</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: red; font-weight: bold;">Nothing</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runParser (return <span class="dv">42</span>) <span class="st">&quot;Hello Parser!&quot;</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: green; font-weight: bold;">Just</span><span style="font-family: monospace;">(42,“Hello Parser!”)</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runParser oneChar <span class="st">&quot;Hello Parser!&quot;</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: green; font-weight: bold;">Just</span><span style="font-family: monospace;">(‘H’,“ello Parser!”)</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runParser oneChar <span class="st">&quot;&quot;</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: red; font-weight: bold;">Nothing</span></p>
<p>The basic parsers seem to behave as expected. We get <code>Nothing</code> in case of failure, and they are able to partially consume the input. So all is good, but what about more complex parsers? We would like to parse strings, or more complex patterns. Let’s try to recognize a string from the input, using our basic parsers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span>
string <span class="st">&quot;&quot;</span> <span class="fu">=</span> return <span class="st">&quot;&quot;</span>
string (c1<span class="fu">:</span>xs1) <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> runParser oneChar s <span class="kw">of</span>
                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
                <span class="dt">Just</span> (c2, rest) <span class="ot">-&gt;</span> <span class="kw">if</span> c1 <span class="fu">==</span> c2
                                    <span class="kw">then</span> <span class="kw">case</span> runParser (string xs1) rest <span class="kw">of</span>
                                        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
                                        <span class="dt">Just</span> (match, rest2) <span class="ot">-&gt;</span> <span class="dt">Just</span> (c2<span class="fu">:</span>match, rest2)
                                    <span class="kw">else</span> <span class="dt">Nothing</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runParser (string <span class="st">&quot;Hello&quot;</span>) <span class="st">&quot;Hello Parser!&quot;</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: green; font-weight: bold;">Just</span><span style="font-family: monospace;">(“Hello”,&quot; Parser!“)</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runParser (string <span class="st">&quot;Hello&quot;</span>) <span class="st">&quot;Foo Bar&quot;</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: red; font-weight: bold;">Nothing</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runParser (string <span class="st">&quot;&quot;</span>) <span class="st">&quot;Hello Parser!&quot;</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: green; font-weight: bold;">Just</span><span style="font-family: monospace;">(“”,“Hello Parser!”)</span></p>
<p>This isn’t very convenient (but it works)… Because we have to write the boilerplate to <em>compose parsers</em> over and over. Hopefully, we know a famous structure that allows composition in Haskell, and this is called <em>Monad</em> (and I won’t make yet another tutorial on <em>Monads</em>, so I will assume you already are familiar with this concept). That means we could avoid all the boilerplate, by making our <code>Parser</code> type an instance of <em>Monad</em>. This would allow us to use the <em>do syntax</em> to cleanly compose our parsers! Sweet!</p>
<p>To do so, we’ll have to make our <em>Parser</em> an instance of: <em>Functor</em>, <em>Applicative</em> and <em>Monad</em>.</p>
<h4 id="parser-is-a-functor">Parser is a Functor</h4>
<p>First of all, our Parser is an instance of <a href="https://en.wikibooks.org/wiki/Haskell/The_Functor_class"><em>Functor</em></a>, which means we can <code>map</code> functions over the result of our parsing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Parser</span> <span class="kw">where</span>
    <span class="co">-- fmap :: (a -&gt; b) -&gt; Parser a -&gt; Parser b</span>
    <span class="co">-- 1. Run parser on input string.</span>
    <span class="co">-- 2. Apply function on result of parsing.</span>
    fmap f p <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> runParser p s <span class="kw">of</span>
                    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
                    <span class="dt">Just</span> (a, rest) <span class="ot">-&gt;</span> <span class="dt">Just</span> (f a, rest)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Parse `String` &quot;42&quot; and then convert it to `Int` using `read`</span>
<span class="ot">parse42 ::</span> <span class="dt">Parser</span> <span class="dt">Int</span>
parse42 <span class="fu">=</span> (fmap read <span class="fu">$</span> string <span class="st">&quot;42&quot;</span>)

runParser parse42 <span class="st">&quot;42 is the answer!&quot;</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: green; font-weight: bold;">Just</span><span style="font-family: monospace;">(42,&quot; is the answer!“)</span></p>
<h4 id="parser-is-an-applicative">Parser is an Applicative</h4>
<p>Secondly, we can make our parser an instance of <a href="https://en.wikibooks.org/wiki/Haskell/Applicative_functors"><em>Applicative</em></a>. This part wasn’t obvious for me. All the examples I found were about instances for easy types like <code>Maybe</code>, but I found a <em>Parser</em> to be pretty different. But thanks to the types and some usecases (that you’ll find below), I figured the following implementation (which will hopefully be correct…):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Parser</span> <span class="kw">where</span>
    <span class="co">-- pure :: a -&gt; Parser a</span>
    <span class="co">-- Wrap a value inside a parser, leaving input unchanged.</span>
    pure a <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, s)
    <span class="co">-- (&lt;*&gt;) :: Parser (a -&gt; b) -&gt; Parser a -&gt; Parser b</span>
    <span class="co">-- 1. Run first parser on input (resulting in a function (a -&gt; b).</span>
    <span class="co">-- 2. Run second parser on remaining input, left by first parser.</span>
    <span class="co">-- 3. Apply function (a -&gt; b) on result of second parser.</span>
    p1 <span class="fu">&lt;*&gt;</span> p2 <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> runParser p1 s <span class="kw">of</span>
                            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
                            <span class="dt">Just</span> (f, rest) <span class="ot">-&gt;</span> <span class="kw">case</span> runParser p2 rest <span class="kw">of</span>
                                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
                                <span class="dt">Just</span> (a, rest2) <span class="ot">-&gt;</span> <span class="dt">Just</span> (f a, rest2)</code></pre></div>
<p>The usefulness of the previous instance might not be obvious, but it allows us to <code>lift</code> some function inside the realm of parsers. For example if we want to take the result of several parsers and then group their results into a tuple, we can do it using <em>Applicatives</em>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTuple ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>)
parseTuple <span class="fu">=</span>  (,) <span class="fu">&lt;$&gt;</span> oneChar <span class="fu">&lt;*&gt;</span> oneChar
runParser parseTuple <span class="st">&quot;ab&quot;</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: green; font-weight: bold;">Just</span><span style="font-family: monospace;">((‘a’,‘b’),“”)</span></p>
<p>This is the kind of constructs we will use to convert the raw parsed structure into our own types (e.g: an AST).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AST</span> <span class="fu">=</span> <span class="dt">Foo</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Bar</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Pair</span> <span class="dt">Char</span> <span class="dt">Char</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)

parseFoo, parseBar,<span class="ot"> parsePair ::</span> <span class="dt">Parser</span> <span class="dt">AST</span>
parseFoo <span class="fu">=</span> <span class="dt">Foo</span> <span class="fu">&lt;$&gt;</span> string <span class="st">&quot;foo&quot;</span>
parseBar <span class="fu">=</span> <span class="dt">Bar</span> <span class="fu">&lt;$&gt;</span> string <span class="st">&quot;bar&quot;</span>
parsePair <span class="fu">=</span> <span class="dt">Pair</span> <span class="fu">&lt;$&gt;</span> oneChar <span class="fu">&lt;*&gt;</span> oneChar</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runParser parseFoo <span class="st">&quot;foo bar&quot;</span>
runParser parseBar <span class="st">&quot;bar baz&quot;</span>
runParser parsePair <span class="st">&quot;xyz&quot;</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: green; font-weight: bold;">Just</span><span style="font-family: monospace;">(Foo “foo”,&quot; bar“)</span></p>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: green; font-weight: bold;">Just</span><span style="font-family: monospace;">(Bar “bar”,&quot; baz“)</span></p>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: green; font-weight: bold;">Just</span><span style="font-family: monospace;">(Pair ‘x’ ‘y’,“z”)</span></p>
<h4 id="parser-is-a-monad">Parser is a Monad</h4>
<p>Last but not least, our parser is a <a href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads"><em>Monad</em></a>. Which means it must implement: <code>&gt;&gt;=</code>, <code>&gt;&gt;</code>, <code>return</code> and <code>fail</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Parser</span> <span class="kw">where</span>
    <span class="co">-- (&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b</span>
    <span class="co">-- 1. Run first parser on input.</span>
    <span class="co">-- 2. Feed result of parsing to `f`.</span>
    <span class="co">-- 3. Run second parser (result of `f`) on remaining input (left by first parser)</span>
    p <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> runParser p s <span class="kw">of</span>
                    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
                    <span class="dt">Just</span> (a, rest) <span class="ot">-&gt;</span> runParser (f a) rest
    <span class="co">-- (&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b</span>
    <span class="co">-- 1. Run first parser on input.</span>
    <span class="co">-- 2. Run second parser on remaining input (left by first parser)</span>
    <span class="co">-- We ignore result of first parser.</span>
    p1 <span class="fu">&gt;&gt;</span> p2 <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> runParser p1 s <span class="kw">of</span>
                    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
                    <span class="dt">Just</span> (_, rest) <span class="ot">-&gt;</span> runParser p2 rest
    <span class="co">-- return :: a -&gt; Parser a</span>
    return <span class="fu">=</span> pure
    <span class="co">-- fail :: String -&gt; Parser a</span>
    fail _ <span class="fu">=</span> <span class="dt">Parser</span> (const <span class="dt">Nothing</span>)</code></pre></div>
<p>Thanks to this definition we can use the <code>do</code> syntactic sugar, which will ease the implementation of more complex parsers. Let’s see what we can do.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Parse a specific `Char` from the input</span>
<span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span>
char c <span class="fu">=</span> <span class="kw">do</span>
    c1 <span class="ot">&lt;-</span> oneChar
    <span class="kw">if</span> c <span class="fu">==</span> c1
       <span class="kw">then</span> return c1
       <span class="kw">else</span> failure</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runParser (char <span class="ch">'H'</span>) <span class="st">&quot;Hello!&quot;</span>
runParser (char <span class="ch">'e'</span>) <span class="st">&quot;Hello!&quot;</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: green; font-weight: bold;">Just</span><span style="font-family: monospace;">(‘H’,“ello!”)</span></p>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: red; font-weight: bold;">Nothing</span></p>
<p>We can also implement a cleaner version of our <code>string</code> parser (found above):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Parse a specific pattern from the input</span>
<span class="ot">string' ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span>
string' [] <span class="fu">=</span> return []
string' (c<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">do</span>
    c1 <span class="ot">&lt;-</span> char c
    rest <span class="ot">&lt;-</span> string' xs
    return (c1<span class="fu">:</span>rest)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runParser (string' <span class="st">&quot;Hello&quot;</span>) <span class="st">&quot;Hello&quot;</span>
runParser (string' <span class="st">&quot;Hello&quot;</span>) <span class="st">&quot;Foo&quot;</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: green; font-weight: bold;">Just</span><span style="font-family: monospace;">(“Hello”,“”)</span></p>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span style="color: red; font-weight: bold;">Nothing</span></p>
<p>The <code>do</code> notation makes it very easy to combine parsers! We now have some basic building blocks that we could use to implement more parsing combinators: <code>choice</code>, <code>many</code>, <code>option</code>, etc. But I’ll leave it as an exercice.</p>
<p>Moreover, it would be interesting to implement an error reporting mechanism, as well as position tracking (to locate errors in the input), but I’ll leave it for another blogpost (or as an exercice for the reader!).</p>
<h2 id="what-i-learned-while-reinventing-the-wheel">What I learned while reinventing the wheel</h2>
<p>Implementing (very) basic parsing combinators led me to better understand the foundation of libraries like <em>Parsec</em> or <em>Attoparsec</em>, and to implement not so trivial instances of typeclasses like <em>Applicatives</em> and <em>Monads</em>. Althoug basic, I think it’s a good way to be more familiar with the <em>DSL</em>-like capabilities of Haskell, and to feel the power that the language offers in term of domain-specific modeling.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
