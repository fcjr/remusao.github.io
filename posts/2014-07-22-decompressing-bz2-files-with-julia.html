<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Simplex Sigillum Veri - Decompressing BZipped files with Julia</title>
        <style>body{background:#ffffff;color:#2e3436;font-family:Verdana,Geneva,sans-serif;margin:0 auto;max-width:40em;padding:0 0.5em}a{border-bottom:thin solid;color:#3465a4;text-decoration:none}a:visited{color:#75507b}header{border-bottom:2px solid black;margin-bottom:30px;padding:12px 0px 12px 0px}nav{text-align:right}nav{color:black;font-size:18px;font-weight:bold;margin-left:12px;text-decoration:none;text-transform:uppercase}footer{border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-size:24px}h2{font-size:20px}article .header{color:#555;font-size:14px;font-style:italic}.logo a{color:black;float:left;font-size:18px;font-weight:bold;text-decoration:none}code{background-color:rgb(250,250,250);border:1px solid rgb(200,200,200);padding-left:4px;padding-right:4px}pre code{display:block;padding:8px;margin-bottom:2em}p.caption{display:none}div.sourceCode{overflow-x:auto}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode{margin:0;padding:0;vertical-align:baseline;border:none}table.sourceCode{width:100%;line-height:100%}td.lineNumbers{text-align:right;padding-right:4px;padding-left:4px;color:#aaaaaa;border-right:1px solid #aaaaaa}td.sourceCode{padding-left:5px}code>span.kw{color:#007020;font-weight:bold}code>span.dt{color:#902000}code>span.dv{color:#40a070}code>span.bn{color:#40a070}code>span.fl{color:#40a070}code>span.ch{color:#4070a0}code>span.st{color:#4070a0}code>span.co{color:#60a0b0;font-style:italic}code>span.ot{color:#007020}code>span.al{color:#ff0000;font-weight:bold}code>span.fu{color:#06287e}code>span.er{color:#ff0000;font-weight:bold}code>span.wa{color:#60a0b0;font-weight:bold;font-style:italic}code>span.cn{color:#880000}code>span.sc{color:#4070a0}code>span.vs{color:#4070a0}code>span.ss{color:#bb6688}code>span.im{}code>span.va{color:#19177c}code>span.cf{color:#007020;font-weight:bold}code>span.op{color:#666666}code>span.bu{}code>span.ex{}code>span.pp{color:#bc7a00}code>span.at{color:#7d9029}code>span.do{color:#ba2121;font-style:italic}code>span.an{color:#60a0b0;font-weight:bold;font-style:italic}code>span.cv{color:#60a0b0;font-weight:bold;font-style:italic}code>span.in{color:#60a0b0;font-weight:bold;font-style:italic}</style>
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Simplex Sigillum Veri</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Decompressing BZipped files with Julia</h1>
            <article>
    <section class="header">
        Posted on July 22, 2014
        
    </section>
    <section>
        <p>I’m currently working with Wikipedia dumps, and to save space, it’s a good thing to make scripts that read directly content from (and write results to) BZipped files.</p>
<h2 id="setup">Setup</h2>
<p>Tests where executed on my personnal computer:</p>
<ul>
<li>i7</li>
<li>16GB of ram</li>
</ul>
<p>On a small wikipedia dump of <em>407MB</em>. All timings are in <em>seconds</em>.</p>
<h2 id="bzcat-alone">bzcat alone</h2>
<p>To have a point of comparison, I decompressed the dump using <em>bzcat</em> alone. The timing is <em>64 seconds</em>.</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="bu">time</span> <span class="op">1&gt;</span>/dev/null bzcat wikidump.xml.bz2</code></pre></div>
<h2 id="using-python">Using Python</h2>
<p>It’s easy enough with <em>Python</em> thanks to the <code>bz2</code> module that allows to transparently manipulate a compressed file as if it were a normal opened file. Before jumping to Julia, let see how it is done in Python:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> __future__ <span class="im">import</span> print_function
<span class="im">import</span> sys
<span class="im">import</span> bz2


<span class="kw">def</span> main():
    in_stream <span class="op">=</span> bz2.BZ2File(sys.argv[<span class="dv">1</span>])
    <span class="cf">for</span> line <span class="kw">in</span> in_stream:
        <span class="bu">print</span>(line)
    in_stream.close()


<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:
    main()</code></pre></div>
<p>Nothing easier, it takes <em>85 seconds</em> to run.</p>
<h2 id="what-about-julia">What about Julia?</h2>
<p>Since I really love <em>Julia</em> language, I was tempted to do the same with Julia. Here are the differents solutions that I went through, with their respective timings.</p>
<h3 id="using-bz2-python-module-through-pycall">Using bz2 Python module through PyCall</h3>
<p>The first naive option is to use the original module from Python. It’s easy enough using the <code>PyCall</code> module. We can install it like so:</p>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia">julia&gt; Pkg.add(<span class="st">&quot;PyCall&quot;</span>)
julia&gt; Pkg.update()</code></pre></div>
<p>The script:</p>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia">using PyCall
@pyimport bz<span class="fl">2</span>

<span class="kw">function</span> main()
    in_stream = bz2.BZ2File(ARGS[<span class="fl">1</span>])
    <span class="kw">for</span> line <span class="kw">in</span> in_stream
        println(line)
    <span class="kw">end</span>
    in_stream[:close]()
<span class="kw">end</span></code></pre></div>
<p>But then we hit the wall… timing is: <em>1352 seconds</em>. This is likely due to the conversion between <em>Python</em> and <em>Julia</em> datatypes. So not the best option for a data-intensive usage.</p>
<h3 id="piping-result-of-bzcat-to-julia">Piping result of bzcat to Julia</h3>
<p>The second option that came to my mind was: “why not using <em>bzcat</em>?”. It’s easy enough, we just have to read from <code>STDIN</code>:</p>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia"><span class="kw">function</span> main()
    <span class="kw">for</span> line <span class="kw">in</span> eachline(STDIN)
        print(line)
    <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<p>Here is the invocation:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">bzcat</span> wikidump.xml.bz2 <span class="kw">|</span> <span class="ex">julia</span> bz2_bench.jl</code></pre></div>
<p>Timing is now a more reasonable <em>72 seconds</em>. So that is less than the <em>Python</em> version shown above. But this is not satisfactory enough. Why not use the wonderful capabilities of <em>Julia</em> to run external commands an pipe results?</p>
<h3 id="invoking-bzcat-from-julia">Invoking bzcat from Julia</h3>
<p>It is easy to invoke commands from inside <em>Julia</em> using backquotes: <code>run(`cmd`)</code> and <code>|&gt;</code> to pipe between commands and streams. Let’s do it:</p>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia"><span class="kw">function</span> main()
    file = ARGS[<span class="fl">1</span>]
    run(`bzcat $(file)` |&gt; STDOUT)
<span class="kw">end</span></code></pre></div>
<p>The script is equivalent to: <code>bzcat wikidump.xml.bz2</code>, but it’s quite impressive to see how easy it is to do this inside a Julia script. This time is about <em>66 seconds</em>, more or less the same than with the external piping from <code>bzcat</code>.</p>
<p>But it would be useful to get lines of contents from the stream, like it was in the original <em>Python</em> script. For this task, <em>Julia</em> standard library offers a multitudes of handy functions. The one we will use is <code>readsfrom</code> that returns two things: stdout of the given process, and the process itself. Here it is in action:</p>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia"><span class="kw">function</span> main()
    file = ARGS[<span class="fl">1</span>]
    stdout, p = readsfrom(`bzcat $(file)`)
    <span class="kw">for</span> line <span class="kw">in</span> eachline(stdout)
        print(line)
    <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<p>Timing is now about <em>74 seconds</em>, this is <em>10 seconds</em> faster than the first <em>Python</em> version. But we don’t rely on a module. Instead, we make use of the ability to play with command invocations, stream pipings, and the like that <em>Julia</em> allows.</p>
<h2 id="timings">Timings</h2>
<div class="figure">
<img src="../images/bz2-julia-bench.png" alt="Bench" />
<p class="caption">Bench</p>
</div>
<p>Timings are relatively close since the big work is done in the decompression, that’s why there isn’t much difference between <em>Julia</em> and <em>Python</em>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I was first tempted to implement a <em>Julia</em> wrapper over <em>bzlib</em>, but what for? When it’s so easy to invoke external commands and manipulate their input and output streams. <em>Julia</em> is a young language, but it’s so flexible and extensible, that often I forget about it!</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
